using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace EthicalHackingSimulator
{
    public class MSModule_Exploit : ITerminal
    {
        private ExploitDB exDB;
        private TargetList tarList;
        public MSExploit createdExploit { get; private set; }
        public bool exitCondition { get; private set; }

        public MSModule_Exploit(ExploitDB exDB, TargetList tarList)
        {
            this.exDB = exDB;
            this.tarList = tarList;
            this.createdExploit = null;
            this.exitCondition = false;
        }

        //Exploit Module console
        public void Terminal()
        {
            string tag = "msf exploit > ";
            char[] splitDelimiters = { ' ' };

            LaunchText();

            while (true)
            {               
                Console.Write(tag);
                string input = Console.ReadLine();

                //Returns to the Megsploit Framework console
                if(input == "back")
                {
                    Console.WriteLine("Quitting Module: Exploit Module...\n");
                    System.Threading.Thread.Sleep(1000);
                    break;
                }

                //Prints the help menu for the Exploit Module
                else if(input == "help")
                {
                    PrintHelp();
                }

                //Clears the console
                else if(input == "clear")
                {
                    Console.Clear();
                }

                //Prints out a list of the exploits available, along with a description of what they are and how they work
                else if(input == "exploits")
                {
                    PrintExploitInfo();
                }

                //Creates an exploit, depending on given input
                else if(input == "create")
                {
                    string exploitName = GetExploitName();

                    if(exploitName != null)
                    {
                        createdExploit = CreateExploit(exploitName);                        
                    }
                }

                //deploys the exploit to the target
                else if(input == "deploy")
                {
                    Console.Write("Enter Target IP Address: ");
                    string ip = Console.ReadLine();
                    Target destination = null;
                    try
                    {
                        destination = tarList.FindTarget(ip);
                    }
                    catch(Exception)
                    {
                        Console.WriteLine("That is not a valid target.\n");
                        continue;
                    }

                    Console.Write("Enter port number of service: ");
                    string p = Console.ReadLine();
                    int port = 0;
                    try
                    {
                        port = Int32.Parse(p);
                    }
                    catch (Exception)
                    {
                        Console.WriteLine("That is not a valid port number.\n");
                        continue;
                    }

                    if (destination != null)
                    {
                        createdExploit.Deploy(destination, port);
                        
                        if(createdExploit.name != "SQL_Injection")
                        {
                            exitCondition = true;
                        }
                    }
                    else
                    {
                        Console.WriteLine("That is not a valid target.\n");
                    }                    
                }

                //Else, Invalid command
                else
                {
                    Console.WriteLine("That is not a valid command.\n");
                }

                if(exitCondition)
                {
                    break;
                }
            }
        }

        //Prompts the user for the name of the exploit they wish to create, depending on input
        private string GetExploitName()
        {
            System.Threading.Thread.Sleep(500);
            Console.Write("What exploit do you wish to create? ");
            string exName = Console.ReadLine();
            Console.Write("For which service? ");
            string serviceName = Console.ReadLine();

            bool validExploit = ValidateExploit(exName);
            bool validService = ValidateService(serviceName);

            if (validExploit && validService)
            {
                Console.WriteLine("Initialising creation of {0} exploit for service: {1}\n", exName, serviceName);
                System.Threading.Thread.Sleep(2000);
                return exName;
            }
            else
            {
                Console.WriteLine("That is not a valid exploit name.\n");
                return null;
            }
        }

        //Validates the exploit name
        private bool ValidateExploit(string exName)
        {
            var exploitList = exDB.exploits;
            bool valid = false;
            
            for (int i = 0; i < exploitList.Count; i++)
            {
                if(exName == exploitList[i])
                {
                    valid = true;
                    break;
                }
            }

            return valid;
        }

        //Validates the service name
        private bool ValidateService(string sName)
        {
            var serviceList = exDB.services;
            bool valid = false;

            for(int i = 0; i < serviceList.Count; i++)
            {
                if(sName == serviceList[i])
                {
                    valid = true;
                    break;
                }
            }

            return valid;
        }

        //Parses the exploit name and creates the appropriate exploit
        private MSExploit CreateExploit(string exName)
        {
            switch(exName)
            {
                case "Buffer_Overflow":
                    var bufferOverflow = new MSExploit_Buffer_Overflow(exName);
                    bufferOverflow.Create();
                    return bufferOverflow;

                case "Reverse_TCP_Shell":
                    var reverseShell = new MSExploit_Reverse_Shell(exName);
                    reverseShell.Create();
                    return reverseShell;

                case "SQL_Injection":
                    var sqlInjection = new MSExploit_SQL_Injection(exName);
                    sqlInjection.Create();
                    return sqlInjection;

                case "Arbitrary_File_Upload":
                    var fileUpload = new MSExploit_File_Upload(exName);
                    fileUpload.Create();
                    return fileUpload;

                case "DoS_Heap_Overflow":
                    var heapOverflow = new MSExploit_Heap_Overflow(exName);
                    heapOverflow.Create();
                    return heapOverflow;

                default:
                    return null;
            }
        }

        //Loading Text
        private void LaunchText()
        {
            Console.WriteLine("Launching Module: Exploit Module...\n");
            System.Threading.Thread.Sleep(1000);
            Console.WriteLine("Exploit Module successfully loaded! Type help for more information!\n");
        }

        //Prints the Exploit Module Help Menu
        public void PrintHelp()
        {
            //Title
            string title = "Megasploit Exploit Module Help Menu:\n\n";

            //Exploits
            string ex1 = "Exploit List: exploits\n";
            string ex2 = "Lists all available exploits along with their descriptions.\n\n";
            string exploits = ex1 + ex2;

            //Exploit Creation
            string create1 = "Exploit Creation: create\n";
            string create2 = "Begins the process of creating exploits.\n";
            string create3 = "Input the name of the exploit and the service which it's for and the exploit will be created (Case Sensitive).\n\n";
            string creation = create1 + create2 + create3;

            //Exploit Deployment
            string deploy1 = "Exploit deployment: deploy\n";
            string deploy2 = "Begins the process of deploying the created exploit to the target.\n";
            string deploy3 = "Input the target's IP address and port number of the service to deploy the exploit.\n\n";
            string deployment = deploy1 + deploy2 + deploy3;

            //Clears the console
            string clear = "To clear the console screen, type 'clear'\n\n";

            //Go back to Megasploit Framework
            string back = "To return to the Megasploit Framework, type 'back'\n\n";

            //Displays the help menu on the screen
            string help = title + exploits + creation + deployment + clear + back;
            Console.WriteLine();
            Console.WriteLine(help);

        }

        //Prints the Exploit List and gives descriptions of each
        public void PrintExploitInfo()
        {
            //Title
            string title = "Exploit List:\n\n";

            //Buffer Overflow
            string bo1 = "Buffer Overflow: Memory failure when data being written to a buffer overruns the buffer boundaries and overwrites adjacent memory locations.\n";
            string bo2 = "By corrupting the adjacent memory locations with No-Op machine instructions, the program will execute these until it meets a Jump instruction that will place the program into malicious shellcode created by the attacker.\n";
            string bo3 = "This is called a Stack Buffer Overflow NOP Sled.\n";
            string bo4 = "Useful in executing malicous code that can render a program useless.\n\n";
            string bufferOverflow = bo1 + bo2 + bo3 + bo4;

            //Arbitrary File Upload.
            string afu1 = "Arbitrary File Upload: Allows for a file to be uploaded onto the targetted service.\n";
            string afu2 = "These files can be harmless or malicious, depending on their contents. FOr the purposes of this simulation, these will be malicious in nature.\n";
            string afu3 = "There are three types of malicious files that can be uploaded in this simulation: Virus, Worm, and Trojan.\n\nArbitrary File Upload Types:\n";
            string virus = "Virus: A malicious file that attaches itself to a host program. This virus will delete key system files on the target's machine.\n";
            string worm = "Worm: Self propagating malicous file that transfers itself through netowrk protocols. This worm will bottleneck bandwith on the target's netowrk.\n";
            string trojan = "Trojan: Malicous file that is disguised as an innocuous program. This trojan will log key strokes on the target's machine and relay them back to the attaker.\n\n";
            string fileUpload = afu1 + afu2 + afu3 + virus + worm + trojan;

            //DoS Heap Overflow
            string dho1 = "Denial of Service Heap Overflow: Memory failure in which the dynamically allocated memory for the program is corrupted to remove memory pointers.\n";
            string dho2 = "By corrupting memory linkages in the Heap memory of a program (Collection of memory available to the program), one can overwrite key memory pointers in the program, rendering it useless.\n";
            string dho3 = "The program will become unresponsive and fail to work until it is restarted, leading to a Denial of Service.\n\n";
            string heapOverflow = dho1 + dho2 + dho3;

            //Reverse TCP Shell
            string rev1 = "Reverse TCP Shell: A script that allows for a remote connection to the target's machine.\n";
            string rev2 = "Spawns a shell on the attacker's machine that will control the target's machine.\n";
            string rev3 = "This is done by the target unknowingly activating the script that will connect to the attacker's machine which will be listening on a specific port number.\n";
            string rev4 = "This type of exploit is extremely powerful as it gives the attacker almost full control of the target's system.\n\n";
            string reverseShell = rev1 + rev2 + rev3 + rev4;

            //SQL Injection
            string sql1 = "SQL Injection: An SQL command that can be sent to an SQL database through an insecure field such as a Username/Password login.\n";
            string sql2 = "The SQL command is not escaped so when sent to the database, the command will be executed and will return the desired information.\n";
            string sql3 = "Powerful exploit as it can lead to comprimising a list of usernames and passwords.\n";
            string sql4 = "Most passwords will be encrypted that can be cracked with other programs but some systems still store passwords in plain text - a massive security flaw.\n";
            string sql5 = "in this simulation, the obtained information could perhaps be used in Telnet...\n\n";
            string sqlInjection = sql1 + sql2 + sql3 + sql4 + sql5;

            string exploits = title + bufferOverflow + fileUpload + heapOverflow + reverseShell + sqlInjection;

            Console.WriteLine(exploits);
        }
    }
}
