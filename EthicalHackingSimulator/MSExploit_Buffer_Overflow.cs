using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace EthicalHackingSimulator
{
    public class MSExploit_Buffer_Overflow : MSExploit
    {
        public MSExploit_Buffer_Overflow(string name) : base(name) { }

        //Creates the Buffer Overflow exploit
        public override void Create()
        {                        
            Console.WriteLine("Assessing overflow type...\n");
            System.Threading.Thread.Sleep(750);            
            Console.WriteLine("Stack buffer overflow detected.\nApproach: NOP-Sled.\n");
            System.Threading.Thread.Sleep(1250);
            Console.WriteLine("Crafting malicious shellcode...");
            System.Threading.Thread.Sleep(500);


            string[] shellcode = ShellCode();
            for(int i = 0; i < shellcode.Length; i++)
            {
                Console.Write(shellcode[i]);
                System.Threading.Thread.Sleep(100);
            }
            Console.WriteLine("\nDone!\n");
            System.Threading.Thread.Sleep(1000);

            OptionalRootkit();

            Console.WriteLine("Compiling...\n");
            System.Threading.Thread.Sleep(2000);
            Console.WriteLine("Buffer overflow exploit sucessfully created and awaiting deployment!\n");
        }

        //Deploys the exploit onto the given target
        public override void Deploy(Target t, int port)
        {
            string service = "";

            try
            {
                service = t.portsAndServices[port];
            }
            catch (Exception)
            {
                Console.WriteLine("That is not a valid port number.\n");
                return;
            }

            Console.WriteLine("Gathering necessary files...");
            System.Threading.Thread.Sleep(2000);
            Console.WriteLine("Deploying {0} to {1} {2} service on port {3}...", this.name, t.ipAddress, service, port);
            System.Threading.Thread.Sleep(3000);
            Console.WriteLine("Success!\n");
            System.Threading.Thread.Sleep(2000);

            t.deployedExploit = this;

            Results();
        }

        //Observe the results of the exploit
        //TODO Maybe fix this up  a bit
        public override void Results()
        {
            Console.WriteLine("Corrupting stack with No-Op machine instructions...");
            System.Threading.Thread.Sleep(3000);
            Console.WriteLine("Attempting to locate return address...");
            System.Threading.Thread.Sleep(1500);
            Console.WriteLine("Location found! Present at memory location: {0}", MemoryLocation());
            System.Threading.Thread.Sleep(500);
            Console.WriteLine("Setting relative jump location to before return address: {0}", MemoryLocation());
            System.Threading.Thread.Sleep(750);
            Console.WriteLine("Setting relative jump location pointing to payload: {0}", MemoryLocation());
            System.Threading.Thread.Sleep(1000);
            Console.WriteLine("Payload address: {0}\n", MemoryLocation());
            Console.WriteLine("Running...");
            System.Threading.Thread.Sleep(4000);
            Console.WriteLine("Executing payload...");
            System.Threading.Thread.Sleep(3000);
            Console.WriteLine("Deleting key program files...");
            System.Threading.Thread.Sleep(2000);
            Console.WriteLine("\nComplete!\n");
        }

        //Creates a random string that resembles a memory location
        private string MemoryLocation()
        {
            Random r = new Random();
            int size = 8;
            string location = "";
            string start = "0x";
            char[] hexadecimal =
            {
                '0','1','2','3','4','5','6','7','8','9','0','a','b','c','d','e','f'
            };

            for(int i = 0; i < size; i++)
            {
                int next = r.Next(0, hexadecimal.Length);

                if (i == 0)
                {
                    location = start + hexadecimal[next];
                }
                else
                {
                    location += hexadecimal[next];
                }
            }

            return location;
        }

        //Creates characters that resemble shellcode
        private string[] ShellCode()
        {
            //hex characters for shellcode
            char[] hex =
            {
                '0','1','2','3','4','5','6','7','8','9','0','a','b','c','d','e','f'
            };

            //Shellcode of max size 30
            string[] code = new string[30];
            string breakChar = "\\x";
            Random r = new Random();

            for(int i = 0; i < code.Length; i++)
            {
                //Picks two random chars from the hex array
                int hex1 = r.Next(0, hex.Length);
                int hex2 = r.Next(0, hex.Length);

                //Prevents the final iteration adding \x at the end by replacing it with \
                if (i == code.Length - 1)
                {
                    code[i] = breakChar + hex[hex1] + hex[hex2] + "\\";
                }
               
                //Justs builds the array as normal
                else
                {
                    code[i] = breakChar + hex[hex1] + hex[hex2];
                }
            }

            return code;            
        }
    }
}
